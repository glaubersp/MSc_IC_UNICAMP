\section{Especificações Heterogêneas: HetCASL e Hets}
Na área de métodos formais e lógica são utilizadas diversas lógicas distintas porque, atualmente, não se conhece uma maneira de combiná-las de forma a obter uma única lógica que se preste a todos os usos desejados. Especificar sistemas grandes, então, exige o uso de especificações heterogêneas porque determinados aspectos são melhor abordados por uma lógica específica. Uma especificação heterogênea possui uma interoperabilidade formal entre as linguagens, de forma que cada linguagem possua seu método de prova e que todas as provas sejam consistentes quando vistas do ponto de vista da especificação heterogênea.

As diversas sub-linguagens e extensões de CASL são únidas pela linguagem ``Heterogeneous CASL (HetCASL)''\cite{MossakowskiWeb}, que possui as construções estruturais de CASL. HetCASL estende a propriedade da semântica de CASL ser independente de instituição com construções que indicam a relação entre a tradução entre especificações que ocorre em conjunto com a tradução entre lógicas. Vale ressaltar que ``HetCASL'' preserva o fato de as lógicas individualmente usadas pelas especificações são ortogonais a CASL.

A ferramenta ``Heterogeneous Tool Set (Hets)''\cite{MossakowskiWeb} é um analisador sintático e um gerenciador de provas para HetCASL, implementado em Haskell, que combina as várias ferramentas de provas existentes para cada uma das lógicas individuais utilizadas nas diversas sub-linguagens e extensões de CASL. Hets baseia-se em um grafo de lógicas e linguagens, provendo uma semântica clara para especificações heterogêneas bem como um cálculo de provas. 

Cada lógica do grafo é representada por um conjunto de tipos e funções em Haskell. A sintaxe e a semânticas das especificações heterogêneas em HetCASL e as suas respectivas implementações são parametrizadas por um grafo de lógicas arbitrário dentro da ferramenta Hets. Isto permite que a implementação da ferramenta e dos módulos para cada lógica sejam facilmente gerenciáveis do ponto de vista de engenharia de software.

Entre as diversas lógicas suportadas por Hets, são de interesse: HasCASL, Haskell, SPASS e Isabelle. As dúas últimas são as únicas que possuem provadores, a saber: SPASS \cite{WBH+02} é um provador automático de teoremas para lógicas de primeira ordem com igualdade; Isabelle \cite{Nipkow-Paulson-Wenzel:2002} é um provador semi-automático de teoremas para lógicas de segunda ordem. As demais lógicas são provadas através de traduções entre elas mesmas e uma das duas lógicas com provadores.

A estrutura de provas em Hets baseia-se no formalismo de grafos de desenvolvimento \cite{Mossakowski2006}, amplamente utilizado para especificações de sistemas industriais. A estrutura de grafos permite a visualização direta da estrutura da especificação e facilita o gerenciamento de especificações com muitas sub-especificações.

Um grafo de desenvolvimento consite em um conjunto de nós (correspondentes a especificações completas ou trechos de especificações) e um conjunto de arcos chamados arcos de definição que indicam a dependencia entre as várias espeficicações e suas sub-especificações. A cada nó estão associados uma assinatura e um conjunto de axiomas locais, sendo que estes últimos são herdados pelos nós dependentes através dos arcos de definição. Diferentes tipos de arcos são utilizados para indicar quando há, ou não, mudança da lógica entre dois nós.

Um segundo tipo de arco, os arcos de teorema, são utilizados para postular relações entre diferentes teorias, servindo para representar as necessidades de prova que surgem durante o desenvolvimento. Os arcos de teorema podem ser globais ou locais (representados por arcos de formas distintas no grafo): os arcos globais indicam que todos os axiomas do nó fonte são válidos no nó alvo; os arcos locais indicam que apenas os axiomas do nó fonte são válidos no nó alvo.

Os arcos de teoria globais são decompostos em arcos mais simples (globais ou locais) atrávés do cálculo de prova para gafos de desenvolvimento. Os arcos locais podem ser provados tranformando-os em alvos locais de prova, os quais podem ser provados utilizando o cálculo de prova da lógica representada no nó.

Abaixo estão reproduzidos dois trechos de códigos utilizados pela ferramentas Hets. O primeiro, escrito na lógica CASL, extende um tipo previamente definido (AllenHayes), incluindo definições e sentenças; estas últimas decorrem das primeiras e geram obrigatoriedade de prova para as sentenças:
\begin{verbatim}
logic CASL
spec ConstructPointsFO[AllenHayes] = %def
  preds __ __ Equi __ __, __ __ Less __ __: Elem x Elem x Elem x Elem 
  forall x,y,z,u:Elem
  . x y Equi z u <=> z M y /\ z M u /\ z M u
  . x y Less z u <=> x M y /\ z M u /\ (exists v:Elem . x M v /\ v M u)
then %implies
  forall x,y,z,u:Elem
  . x M y => x y Equi x y
  . x y Equi z u => z u Equi x y
\end{verbatim}


O segundo exemplo, escrito na lógica HasCASL, especifica uma interface, declarando um predicado visível nesta interface e definindo seu funcionamento através de uma sentença:
\begin{verbatim}
logic HasCASL
view FlowOfTime_In_ConstructPointsFromIntervals[AllenHayes]:
  FlowOfTime to
  { ConstructPointsFromIntervals[AllenHayes] then %def
    pred __ < __ : Inst X Inst
    forall X,Y:Inst . X < Y <=> exists x,y,u,v:Elem
      . x M y /\ u M v /\ X = eqcl(x,y)/\ Y = eqcl(u,v) 
        /\ x y Less u v}
= sort Elem |-> Inst
\end{verbatim}

O código do qual os trechos foram retirados origina o grafo de desenvolvimento da Figura~\ref{grafo}.

\begin{figure}[ht] 
 \centering 
 \includegraphics[width=0.9\textwidth]{grafo} 
 \caption{Exemplo de grafo de desenvolvimento} 
 \label{grafo} 
\end{figure}