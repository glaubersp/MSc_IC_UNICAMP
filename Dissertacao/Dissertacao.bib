%% This BibTeX bibliography file was created using BibDesk.
%% http://bibdesk.sourceforge.net/


%% Created for Glauber at 2010-06-15 18:50:14 -0300 


%% Saved with string encoding Unicode (UTF-8) 


@comment{jabref-meta: selector_publisher:}
@comment{jabref-meta: selector_author:}
@comment{jabref-meta: selector_journal:}
@comment{jabref-meta: selector_keywords:}



@article{Brucker2003HOLZ2,
	Author = {A.D. Brucker and F. Rittinger and B. Wolff},
	Date-Added = {2010-06-15 18:20:39 -0300},
	Date-Modified = {2010-06-15 18:50:08 -0300},
	Journal = {Journal of Universal Computer Science},
	Number = {2},
	Pages = {152--172},
	Title = {{HOL-Z 2.0: A Proof Environment for Z-Specifications}},
	Url = {http://www.jucs.org/jucs_9_2/hol_z_2},
	Volume = {9},
	Year = {2003},
	Abstract = {We present a new proof environment for the specification language Z. The basis is a semantic representation of Z in a structure-preserving, shallow embedding in Isabelle/HOL. On top of the embedding, new proof support for the Z schema calculus and for proof structuring are developed. Thus, we integrate Z into a well-known and trusted theorem prover with advanced deduction technology such as higher-order rewriting, tableaux-based provers and arithmetic decision procedures. A further achievement of this work is the integration of our embedding into a new tool-chain providing a Z-oriented type checker, documentation facilities and macro support for refinement proofs, as a result, the gap has been closed between a logical embedding proven correct and a tool suited for applications of nontrivial size.},
	Bdsk-Url-1 = {http://www.jucs.org/jucs_9_2/hol_z_2}}

@article{Stocks1996,
	Address = {Piscataway, NJ, USA},
	Author = {Stocks, Phil and Carrington, David},
	Date-Added = {2010-06-15 18:07:51 -0300},
	Date-Modified = {2010-06-15 18:08:30 -0300},
	Doi = {10.1109/32.553698},
	Issn = {0098-5589},
	Journal = {{IEEE} Transactions on Software Engineering},
	Number = {11},
	Pages = {777--793},
	Publisher = {IEEE Press},
	Title = {A Framework for Specification-Based Testing},
	Volume = {22},
	Year = {1996},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/32.553698}}

@misc{ArthanProofPower,
	Author = {R. D. Arthan},
	Date-Added = {2010-06-15 18:03:24 -0300},
	Date-Modified = {2010-06-15 18:05:49 -0300},
	Title = {The {ProofPower} Tools},
	Url = {http://www.lemma-one.com/ProofPower/index/index.html},
	Bdsk-Url-1 = {http://www.lemma-one.com/ProofPower/index/index.html}}

@periodical{King1996,
	Author = {D. J. King and R. D. Arthan},
	Booktitle = {{D}evelopment of {P}ratical {V}erification {T}ools},
	Date-Added = {2010-06-15 17:56:50 -0300},
	Date-Modified = {2010-06-15 18:03:21 -0300},
	Journal = {ICL Systems Journal},
	Title = {{D}evelopment of {P}ratical {V}erification {T}ools},
	Url = {http://www.lemma-one.com/ProofPower/papers/icltj.ps.gz},
	Volume = {11},
	Year = {1996},
	Bdsk-Url-1 = {http://www.lemma-one.com/ProofPower/papers/icltj.ps.gz}}

@misc{SpiveyFuzzTypeChecker,
	Author = {J. Michael Spivey},
	Date-Added = {2010-06-15 17:44:47 -0300},
	Date-Modified = {2010-06-15 17:51:08 -0300},
	Title = {The fuzz type-checker for {Z}},
	Url = {http://spivey.oriel.ox.ac.uk/mike/fuzz/},
	Bdsk-Url-1 = {http://spivey.oriel.ox.ac.uk/mike/fuzz/}}

@misc{SpiveyZWordTools,
	Author = {J. Michael Spivey},
	Date-Added = {2010-06-15 17:37:43 -0300},
	Date-Modified = {2010-06-15 17:50:59 -0300},
	Title = {{Z Word Tools}},
	Url = {http://zwordtools.sourceforge.net/},
	Bdsk-Url-1 = {http://zwordtools.sourceforge.net/}}

@inproceedings{Malik2005CZT,
	Author = {Malik, Petra and Utting, Mark},
	Booktitle = {{ZB} 2005: Formal Specification and Development in {Z} and {B} 2005: Formal Specification and Development in Z and B},
	Date-Added = {2010-06-15 17:26:44 -0300},
	Date-Modified = {2010-06-15 18:10:38 -0300},
	Doi = {10.1007/11415787_5},
	Pages = {65-84},
	Publisher = {Springer},
	Series = {Lecture Notes in Computer Science},
	Title = {{CZT}: A Framework for {Z} Tools},
	Volume = {3455},
	Year = {2005},
	Abstract = {The Community Z Tools (CZT) project is an open-source Java framework for building formal methods tools for Z and Z dialects. It also includes a set of tools for parsing, typechecking, transforming and printing standard Z specifications in , Unicode or XML formats. This paper gives an overview of the CZT framework, including an introduction to its visitor design pattern that makes it possible to write new Z transformation tools in just a few lines of Java code. The paper also discusses several problems and challenges that arose when attempting to build tools based on the SO Standard for Z.},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/11415787_5}}

@inbook{MaudeLib,
	Author = {Manuel Clavel and Francisco Dur{\'a}n and Steven Eker and Patrick Lincoln and Narciso Mart{\'\i}-Oliet and Jos{\'e} Meseguer and Carolyn Talcott},
	Booktitle = {All About Maude - A High-Performance Logical Framework},
	Chapter = {9},
	Crossref = {MaudeBook},
	Doi = {10.1007/978-3-540-71999-1_9},
	Pages = {231-305},
	Publisher = {Springer},
	Series = {Lecture Notes in Computer Science},
	Title = {{Predefined Data Modules}},
	Volume = {4350},
	Year = {2007},
	Abstract = {Maude has a standard library of predefined modules that, by default,
	are entered into the system at the beginning of each session, so
	that any of these predefined modules can be imported by any other
	module defined by the user. Also, by default, the predefined functional
	module BOOL is automatically imported (in including mode) as a submodule
	of any user-defined module, unless such importation is explicitly
	disabled. These modules can be found in the file prelude.maude that
	is part of the Maude distribution.
	
	We describe below those predefined modules that provide commonly used
	data types, including Booleans, numbers, strings, and quoted identifiers.
	The relationships among these modules are shown in the importation
	graph in Figure 9.1, where all the importations are in protecting
	mode.
	
	We also describe typical parameterized collections of data types such
	as lists and sets, and associations such as maps and arrays. The
	chapter ends introducing the built-in linear Diophantine equation
	solver, defined in the file linear.maude that is also part of the
	Maude distribution.
	
	Other predefined modules, also in the prelude.maude file, are discussed
	later; more specifically, the META-LEVEL module is discussed in Chapter
	14, the LOOP-MODE module in Section 17.1, and the CONFIGURATION module
	in Sections 11.1 and 11.4.
	
	Furthermore, this chapter also describes a predefined module MACHINE-INT
	for machine integers, which is obtained from the module INT of (arbitrary
	size) integers, but is distributed in a separate file machine-int.maude.},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/978-3-540-71999-1_9}}

@inbook{Roggenbach:2004:CASL-Libraries,
	Author = {Markus Roggenbach and Till Mossakowski and Lutz Schr{\"o}der},
	Chapter = {V},
	Crossref = {CoFI:2004:CASL-RM},
	Doi = {10.1007/b96103},
	Isbn = {978-3-540-21301-7},
	Pages = {163-171},
	Publisher = {Springer},
	Title = {CASL Libraries}},
	Volume = {2960},
	Year = {2004},
	Abstract = {This part of the \textsc{Casl} reference manual describes a library
	of elementary specifications called the Basic Datatypes. This library
	has been developed with two main purposes in mind: on the one hand,
	it provides the user with a handy set of off-the-shelf specifications
	to be used as building blocks in the same way as library functions
	in a programming language, thus avoiding continuous reinvention of
	the wheel. On the other hand, it serves as a large reservoir of example
	specifications that illustrate both the use of \textsc{Casl} at the
	level of basic and structured specifications. \par The name Basic
	\emph{Datatypes} is actually slightly misleading in that there are
	both monomorphic specifications of typical datatypes \emph{and} loose
	specifications that express properties e.g.\ of an algebraic or order
	theoretic nature. The first type of specification includes simple
	datatypes like numbers and characters as well as structured datatypes
	(typically involving type parameters) such as lists, sets, arrays,
	or matrices. The second type of specification is oriented more closely
	towards traditional mathematical concepts; e.g.\ there are specifications
	of monoids and rings, as well as equivalence relations or partial
	orders. The library is structured partly along precisely these lines;
	an overview of the sublibraries is given in Sect.~1.1. \par In the
	design of a library of basic specifications, there is a certain amount
	of tension between the contradicting goals of \begin{itemize} \item
	keeping specifications simple and readable also for novice users,
	and \item making them economical, concise, and amenable for tool
	support. \end{itemize} This concerns in particular the degree of
	structuring, with parametrized specifications being most prominent
	as on the one hand increasing elegance and reusability and on the
	other hand placing on the reader the burden of looking up imported
	specifications and keeping track of signature translations. With
	the exception of the library of numbers, the libraries exhibit a
	certain bias towards more extensive use of structuring operations.
	Several measures have been undertaken to enhance readability of the
	specifications, one of them being the facility to have the signatures
	for the specifications in a library explicitly listed by the \textsc{Casl}
	tools. \par The specifications make use of a set of annotations concerning
	semantics and operator precedences; moreover, we use the \textsc{Casl}
	syntax for literals. The details of these annotations and syntax
	extensions are explained in Chap.~II:5. of the \textsc{Casl} Language
	Syntax. \par The material is organized as follows. After the above-mentioned
	descriptions of the component libraries (Section~1.1), the actual
	content of the libraries is presented in Chaps.~2--11. Chapter~12
	contains graphical representations of the dependencies between the
	specifications. Moreover, there is an index of all library and specification
	names at the end of the book.},
	Annote = {Provides libraries of basic datatypes in \textsc{Casl}, including
	order-theoretic and basic algebraic concepts, simple and structured
	datatypes, and graphs.},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/b96103}}

@article{Astesiano2002,
	Author = {Egidio Astesiano and Michel Bidoit and H{\'e}l{\`e}ne Kirchner and Bernd Krieg-Br{\"u}ckner and Peter D. Mosses and Donald Sannella and Andrzej Tarlecki},
	Doi = {10.1016/S0304-3975(01)00368-1},
	Issn = {0304-3975},
	Journal = {Theoretical Computer Science},
	Number = {2},
	Pages = {153-196},
	Title = {{CASL: The Common Algebraic Specification Language}},
	Volume = {286},
	Year = {2002},
	Abstract = {The Common Algebraic Specification Language (C) is an expressive language
	for the formal specification of functional requirements and modular
	design of software. It has been designed by CFI, the international
	Common Framework Initiative for algebraic specification and development.
	It is based on a critical selection of features that have already
	been explored in various contexts, including subsorts, partial functions,
	first-order logic, and structured and architectural specifications.
	C should facilitate interoperability of many existing algebraic prototyping
	and verification tools. This paper gives an overview of the C design.
	The major issues that had to be resolved in the design process are
	indicated, and all the main concepts and constructs of C are briefly
	explained and illustrated -- the reader is referred to the C Language
	Summary for further details. Some familiarity with the fundamental
	concepts of algebraic specification would be advantageous.},
	Bdsk-Url-1 = {http://dx.doi.org/10.1016/S0304-3975(01)00368-1}}

@other{BToolkit,
	Author = {{B-Core (UK) Ltd}},
	Title = {{B} Toolkit},
	Url = {http://www.b-core.com/btoolkit.html},
	Bdsk-Url-1 = {http://www.b-core.com/btoolkit.html}}

@inproceedings{BadeauA05,
	Author = {Fr{\'e}d{\'e}ric Badeau and Arnaud Amelot},
	Booktitle = {{ZB} 2005: Formal Specification and Development in {Z} and {B}},
	Doi = {10.1007/11415787_20},
	Ee = {http://dx.doi.org/10.1007/11415787_20},
	Pages = {334-354},
	Publisher = {Springer},
	Series = {Lecture Notes in Computer Science},
	Title = {{Using B as a High Level Programming Language in an Industrial Project: Roissy VAL}},
	Volume = {3455},
	Year = {2005},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/11415787_20}}

@techreport{Spectrum,
	Author = {M. Broy and C. Facchi and R. Grosu and R. Hettler and H. Hussmann and D. Nazareth and F. Regensburger and O. Slotosch and K. St{\o}len},
	Institution = {Technische Universit{\"a}t M{\"u}nchen. Institut f{\"u}r Informatik},
	Number = {TUM-I9311},
	Title = {{The Requirement and Design Specification Language Spectrum. An Informal Introduction. Version 1.0. Part I}},
	Url = {http://www4.informatik.tu-muenchen.de/proj/korso/papers/v10.html},
	Year = {1993},
	Bdsk-Url-1 = {http://www4.informatik.tu-muenchen.de/proj/korso/papers/v10.html}}

@book{MaudeBook,
	Author = {Manuel Clavel and Francisco Dur{\'a}n and Steven Eker and Patrick Lincoln and Narciso Mart{\'\i}-Oliet and Jos{\'e} Meseguer and Carolyn Talcott},
	Doi = {10.1007/978-3-540-71999-1},
	Isbn = {978-3-540-71940-3},
	Publisher = {Springer},
	Series = {Lecture Notes in Computer Science},
	Title = {{All About Maude - A High-Performance Logical Framework}},
	Volume = {4350},
	Year = {2007},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/978-3-540-71999-1}}

@other{AtelierB,
	Author = {{ClearSy System Engineering}},
	Title = {{Atelier B}},
	Url = {http://www.atelierb.eu},
	Bdsk-Url-1 = {http://www.atelierb.eu}}

@book{CoFI:2004:CASL-RM,
	Author = {{The CoFI Language Design Group} and Bernd Krieg-Br{\"u}ckner and Peter D. Mosses},
	Doi = {10.1007/b96103},
	Editor = {Peter D. Mosses},
	Publisher = {Springer},
	Series = {Lecture Notes in Computer Science},
	Title = {CASL Reference Manual}},
	Volume = {2960},
	Year = {2004},
	Abstract = {\textsc{Casl}, the \emph{Common Algebraic Specification Language},
	has been designed by CoFI, the \emph{Common Framework Initiative}
	for algebraic specification and development. \textsc{Casl} is an
	expressive language for specifying requirements and design for conventional
	software. It is algebraic in the sense that models of \textsc{Casl}
	specifications are algebras; the axioms can be arbitrary first-order
	formulas. \par \textsc{Casl} is a major new algebraic specification
	language. It has been carefully designed by a large group of experts
	as a general-purpose language for practical use in software development
	-- in particular, for specifying both requirements and design. \textsc{Casl}
	includes carefully-selected features from many previous specification
	languages, as well as some novel features that allow algebraic specifications
	to be written much more concisely and perspicuously than hitherto.
	It may ultimately replace most of the previous languages, and provide
	a common basis for future research and development. \par \textsc{Casl}
	has already attracted widespread interest within the algebraic specification
	community, and is generally regarded as a de facto standard. Various
	sublanguages of \textsc{Casl} are available -- primarily for use
	in connection with existing tools that were developed in connection
	with previous languages. Extensions of \textsc{Casl} provide languages
	oriented toward development of particular kinds of software (reactive,
	concurrent, etc.) \par Major libraries of validated \textsc{Casl}
	specifications are freely available on the Internet, and the specifications
	can be reused simply by referring to their names. Tools are provided
	to support practical use of \textsc{Casl}: checking the correctness
	of specifications, proving facts about them, and managing the formal
	software development process. \par This reference manual gives a
	detailed presentation of the \textsc{Casl} specification formalism.
	It reviews the main underlying concepts, and carefully summarizes
	the intended meaning of each construct of \textsc{Casl}. It formally
	defines both the syntax and semantics of \textsc{Casl}, and presents
	a logic for reasoning about \textsc{Casl} specifications. It also
	provides extensive libraries of \textsc{Casl} specifications of basic
	datatypes, and an annotated bibliography of CoFI publications.},
	Annote = {Gives full details of the design of \textsc{Casl}: an informal language
	summary, concrete and abstract syntax, well-formedness and model-class
	semantics, and proof rules. Includes the libraries of basic datatypes.},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/b96103}}

@book{CafeOBJReport,
	Address = {Singapure},
	Author = {R\u{a}zvan Diaconescu and Kokichi Futatsugi},
	Pages = {196},
	Publisher = {World Scientific Publishing Co.},
	Series = {AMAST Series in Computing},
	Title = {{\textsf{CafeOBJ} Report: The Language, Proof Techniques, and Methodologies for Object-Oriented Algebraic Specification}},
	Volume = {6},
	Year = {1998},
	Abstract = {CafeOBJ is an industrial strength modern algebraic specification language,
	a successor of the famous OBJ language, and directly incorporating
	new paradigms such as behavioural concurrent specification and rewriting
	logic. CafeOBJ is the core of an environment supporting the systems
	(mainly software but not only) development process at several levels,
	including prototyping, specification, and formal verification.
	
	
	This book presents the formal definition of the language and its semantics,
	but also methodologies for specification and verification in CafeOBJ,
	with emphasize on concurrent object composition and modularity.
	
	
	The presentation of the CafeOBJ concepts is supported by many examples,
	and an appendix illustrates the power of the language and its methodologies
	by a larger CASE study including specification, testing, and verification.
	
	
	The book might be used both by software engineers interested in algebraic
	methodologies, and by students and researchers in software engineering
	and/or theoretical computing science as a fast introduction to state-of-the-art
	algebraic specification.}}

@other{FMWikiZ,
	Author = {{Formal Methods Wiki}},
	Title = {Tool support for {Z} language},
	Url = {http://formalmethods.wikia.com/wiki/Z#Tool_support},
	Bdsk-Url-1 = {http://formalmethods.wikia.com/wiki/Z#Tool_support}}

@book{MLLib,
	Author = {Gansner, Emden R. and Reppy, John H.},
	Isbn = {0-52179-478-1},
	Publisher = {Cambridge University Press},
	Title = {{The Standard ML Basis Library}},
	Url = {http://www.standardml.org/Basis/},
	Year = {2002},
	Bdsk-Url-1 = {http://www.standardml.org/Basis/}}

@book{LarchBook,
	Author = {John V. Guttag and James J. Horning},
	Isbn = {0-387-94006-5},
	Pages = {250},
	Publisher = {Springer},
	Title = {{Larch: Languages and Tools for Formal Specifications}},
	Url = {http://nms.lcs.mit.edu/Larch/pub/larchBook.ps},
	Year = {1993},
	Bdsk-Url-1 = {http://nms.lcs.mit.edu/Larch/pub/larchBook.ps}}

@inproceedings{ProgramaticaOverview,
	Author = {Thomas Hallgren and James Hook and Mark P. Jones and Richard B. Kieburtz},
	Booktitle = {High Confidence Software and Systems Conference (HCSS04)},
	Title = {{An Overview of the Programatica ToolSet}},
	Url = {http://www.cse.ogi.edu/~hallgren/ Programatica/HCSS04},
	Year = {2004},
	Bdsk-Url-1 = {http://www.cse.ogi.edu/~hallgren/%20Programatica/HCSS04}}

@misc{learnHaskell,
	Author = {{Haskell Team}},
	Title = {{Learning Haskell}},
	Url = {http://www.haskell.org/haskellwiki/Learning\_Haskell},
	Year = {2007},
	Bdsk-Url-1 = {http://www.haskell.org/haskellwiki/Learning%5C_Haskell}}

@inproceedings{VSE,
	Author = {Dieter Hutter and Heiko Mantel and Georg Rock and Werner Stephan and Andreas Wolpers and Michael Balser and Wolfgang Reif and Gerhard Schellhorn and Kurt Stenzel},
	Booktitle = {Applied Formal Methods - FM-Trends 98 -- International Workshop on Current Trends in Applied Formal Method},
	Doi = {10.1007/3-540-48257-1_26},
	Editor = {Dieter Hutter and Werner Stephan and Paolo Traverso and Markus Ullmann},
	Pages = {351-358},
	Publisher = {Springer},
	Series = {Lecture Notes in Computer Science},
	Title = {{VSE: Controlling the Complexity in Formal Software Developments}},
	Volume = {1641},
	Year = {1998},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/3-540-48257-1_26}}

@misc{IsabelleSite,
	Author = {{Isabelle Comunity}},
	Title = {{Isabelle Overview}},
	Url = {http://isabelle.in.tum.de/overview.html},
	Year = {2007},
	Bdsk-Url-1 = {http://isabelle.in.tum.de/overview.html}}

@book{VDM,
	Author = {Cliff B. Jones},
	Edition = {2nd},
	Isbn = {0-13-880733-7},
	Pages = {333},
	Publisher = {Prentice-Hall, Inc.},
	Title = {{Systematic software development using VDM}},
	Year = {1990}}

@techreport{MLDef,
	Author = {Stefan Kahrs and Donald Sannella and Andrzej Tarlecki},
	Institution = {Laboratory for Foundations of Computer Science, University of Edinburgh},
	Number = {ECS-LFCS-94-300},
	Title = {{The Definition of Extended ML}},
	Url = {http://homepages.inf.ed.ac.uk/dts/eml/eml-final.ps},
	Year = {1997},
	Bdsk-Url-1 = {http://homepages.inf.ed.ac.uk/dts/eml/eml-final.ps}}

@article{MLDefIntro,
	Author = {Stefan Kahrs and Donald Sannella and Andrzej Tarlecki},
	Doi = {10.1016/S0304-3975(96)00163-6},
	Issn = {0304-3975},
	Journal = {Theoretical Computer Science},
	Number = {2},
	Pages = {445 - 484},
	Title = {{The Definition of Extended ML: A Gentle Introduction}},
	Volume = {173},
	Year = {1997},
	Abstract = {Extended ML (EML) is a framework for the formal development of modular
	Standard ML (SML) software systems. Development commences with a
	specification of the behaviour required and proceeds via a sequence
	of partial solutions until a complete solution, an executable SML
	program, is obtained. All stages in this development process are
	expressed in the EML language, an extension of SML with axioms for
	describing properties of module components. This is an overview of
	the formal definition of the EML language. To complement the full
	technical details presented elsewhere, it provides an informal explanation
	of the main ideas, gives the rationale for certain design decisions,
	and outlines some of the technical issues involved. EML is unusual
	in being built around a #real# programming language having a syntax
	and semantics formally defined. Interesting and complex problems
	arise both from the nature of this relationship and from interactions
	between the features of the language.},
	Bdsk-Url-1 = {http://dx.doi.org/10.1016/S0304-3975(96)00163-6}}

@article{Mossakowski2006,
	Author = {Till Mossakowski and Serge Autexier and Dieter Hutter},
	Ee = {http://dx.doi.org/10.1016/j.jlap.2005.09.005},
	Journal = {Journal of Logic and Algebraic Programming},
	Number = {1-2},
	Pages = {114-145},
	Title = {{D}evelopment graphs - {P}roof management for structured specifications},
	Url = {http://www.informatik.uni-bremen.de/~till/papers/dgh_journal.ps},
	Volume = {67},
	Year = {2006},
	Bdsk-Url-1 = {http://www.informatik.uni-bremen.de/~till/papers/dgh_journal.ps}}

@incollection{MossakowskiEtAl07b,
	Author = {Till Mossakowski and Christian Maeder and Klaus L{\"u}ttich},
	Booktitle = {VERIFY 2007, 4th International Verification Workshop},
	Editor = {Bernhard Beckert},
	Keywords = {heterogeneous theorem proving tools logic proofs},
	Pages = {119-135},
	Pdfurl = {http://sunsite.informatik.rwth-aachen.de/Publications/CEUR-WS/Vol-259/paper11.pdf},
	Series = {CEUR Workshop Proceedings},
	Status = {Reviewed},
	Title = {{The Heterogeneous Tool Set}},
	Url = {http://CEUR-WS.org/Vol-259},
	Volume = {259},
	Year = {2007},
	Abstract = {Heterogeneous specification becomes more and more important because
	complex systems are often specified using multiple viewpoints, involving
	multiple formalisms. Moreover, a formal software development process
	may lead to a change of formalism during the development. However,
	current research in integrated formal methods only deals with ad-hoc
	integrations of different formalisms.
	
	The heterogeneous tool set (Hets) is a parsing, static analysis and
	proof management tool combining various such tools for individual
	specification languages, thus providing a tool for heterogeneous
	multi-logic specification. Hets is based on a graph of logics and
	languages (formalized as so-called institutions), their tools, and
	their translations. This provides a clean semantics of heterogeneous
	specifications, as well as a corresponding proof calculus. For proof
	management, the calculus of development graphs (known from other
	large-scale proof management systems) has been adapted to heterogeneous
	specification. Development graphs provide an overview of the (heterogeneous)
	specification module hierarchy and the current proof state, and thus
	may be used for monitoring the overall correctness of a heterogeneous
	development.
	
	We illustrate the approach with a sample heterogeneous proof proving
	the correctness of the composition table of a qualitative spatial
	calculus. The proof involves two different provers and logics: an
	automated first-order prover solving the vast majority of the goals,
	and an interactive higher-order prover used to prove a few bridge
	lemmas.},
	Bdsk-Url-1 = {http://CEUR-WS.org/Vol-259}}

@book{ZMoura,
	Author = {Arnaldo Vieira Moura},
	Isbn = {85-268-0575-4},
	Publisher = {Editora da Unicamp},
	Series = {T{\'\i}tulos em Engenharia de Software},
	Title = {{Especifica{\c c}{\~o}es em Z: Uma Introdu{\c c}{\~a}o}},
	Volume = {3},
	Year = {2001}}

@book{Nipkow-Paulson-Wenzel:2002,
	Author = {Tobias Nipkow and Lawrence C. Paulson and Markus Wenzel},
	Doi = {10.1007/3-540-45949-9},
	Isbn = {978-3-540-43376-7},
	Pages = {218},
	Publisher = {Springer},
	Series = {Lecture Notes in Computer Science},
	Title = {{I}sabelle/{HOL} --- A Proof Assistant for Higher-Order Logic},
	Volume = {2283},
	Year = {2002},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/3-540-45949-9}}

@inproceedings{BMethod,
	Author = {Robinson, Ken},
	Booktitle = {AMAST '97: Proceedings of the 6th International Conference on Algebraic Methodology and Software Technology},
	Isbn = {3-540-63888-1},
	Pages = {576--580},
	Publisher = {Springer},
	Title = {{The B Method and the B Toolkit}},
	Year = {1997}}

@article{MLSurvay,
	Address = {New York, NY, USA},
	Author = {Sannella, Donald and Tarlecki, Andrzei},
	Doi = {10.1145/333580.333589},
	Issn = {0360-0300},
	Journal = {ACM Computing Surveys},
	Number = {3},
	Pages = {10},
	Publisher = {ACM},
	Title = {{Algebraic methods for specification and formal development of programs}},
	Volume = {31},
	Year = {1999},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/333580.333589}}

@inproceedings{Schroder07a,
	Author = {Lutz Schr{\"o}der},
	Booktitle = {Algebra and Coalgebra in Computer Science (CALCO 07)},
	Doi = {10.1007/978-3-540-73859-6_30},
	Editor = {Till Mossakowski and Udo Montanari},
	Keywords = {HasCASL algebra coalgebra process type datatype quasitopos},
	Note = {Extended version available in http://www.informatik.uni-bremen.de/~lschrode/papers/HasCASLtypes-ext.pdf},
	Pages = {447-462},
	Pdfurl = {http://www.informatik.uni-bremen.de/~lschrode/papers/HasCASLtypes.pdf},
	Publisher = {Springer},
	Series = {Lecture Notes in Computer Science},
	Status = {Reviewed},
	Title = {Bootstrapping Types and Cotypes in HasCASL},
	Url = {http://www.informatik.uni-bremen.de/~lschrode/papers/HasCASLtypes.pdf},
	Volume = {4624},
	Year = {2007},
	Abstract = {We discuss the treatment of initial datatypes and final process types
	in the wide-spectrum language HasCASL. In particular, we present
	specifications that illustrate how datatypes and process types arise
	as bootstrapped concepts using HasCASL's type class mechanism, and
	we describe constructions of types of finite and infinite trees that
	establish the conservativity of datatype and process type declarations
	adhering to certain reasonable formats. The latter amounts to modifying
	known constructions from HOL to avoid unique choice; in categorical
	terminology, this means that we establish that quasitoposes with
	an internal natural numbers object support initial algebras and final
	coalgebras for a range of polynomial functors, thereby partially
	generalizing corresponding results from topos theory.},
	Bdsk-Url-1 = {http://www.informatik.uni-bremen.de/~lschrode/papers/HasCASLtypes.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-540-73859-6_30}}

@article{Schroder05b,
	Author = {Lutz Schr{\"o}der},
	Doi = {10.1016/j.tcs.2005.06.037},
	Journal = {Theoretical Computer Science},
	Keywords = {partial lambda-calculus partial cartesian closed category Henkin model HasCASL CASL},
	Pages = {1-25},
	Pdfurl = {http://www.informatik.uni-bremen.de/~lschrode/hascasl/prologue.pdf},
	Psurl = {http://www.informatik.uni-bremen.de/~lschrode/hascasl/prologue.ps},
	Title = {The {HasCASL} Prologue - Categorical Syntax and Semantics of the Partial {$\lambda$}-calculus},
	Url = {http://www.informatik.uni-bremen.de/~lschrode/hascasl/prologue.pdf},
	Volume = {353},
	Year = {2006},
	Abstract = {We develop the semantic foundations of the specification language
	HasCASL, which combines algebraic specification and functional programming
	on the basis of Moggi's partial {$\lambda$}-calculus. Generalizing
	Lambek's classical equivalence between the simply typed {$\lambda$}-calculus
	and cartesian closed categories, we establish an equivalence between
	partial cartesian closed categories (pccc's) and partial {$\lambda$}-theories.
	Building on these results, we define (set-theoretic) notions of intensional
	Henkin model and syntactic {$\lambda$}-algebra for Moggi's partial
	{$\lambda$}-calculus. These models are shown to be equivalent to
	the originally described categorical models in pccc's via the global
	element construction. The semantics of HasCASL is defined in terms
	of syntactic {$\lambda$}-algebras. Correlations between logics and
	classes of categories facilitate reasoning both on the logical and
	on the categorical side; as an application, we pinpoint unique choice
	as the distinctive feature of topos logic (in comparison to intuitionistic
	higher-order logic of partial functions, which by our results is
	the logic of pccc's with equality). Finally, we give some applications
	of the model-theoretic equivalence result to the semantics of HasCASL
	and its relation to first-order CASL.},
	Bdsk-Url-1 = {http://www.informatik.uni-bremen.de/~lschrode/hascasl/prologue.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.tcs.2005.06.037}}

@phdthesis{Schroder2006,
	Author = {Lutz Schr{\"o}der},
	Title = {{Higher Order and Reactive Algebraic Specification and Development}},
	Url = {http://www.informatik.uni-bremen.de/~lschrode/papers/Summary.ps},
	Year = {2006},
	Bdsk-Url-1 = {http://www.informatik.uni-bremen.de/~lschrode/papers/Summary.ps}}

@inproceedings{SchroderMossakowski02,
	Author = {Lutz Schr{\"o}der and Till Mossakowski},
	Booktitle = {Algebraic Methodology And Software Technology (AMAST 2002)},
	Doi = {10.1007/3-540-45719-4_8},
	Editor = {H{\'e}l{\`e}ne Kirchner and Christophe Ringeissen},
	Keywords = {CASL HasCASL general recursion functional programming partial lambda-calculus},
	Pages = {153--180},
	Psurl = {http://www.informatik.uni-bremen.de/~lschrode/hascasl/recursion.ps},
	Publisher = {Springer},
	Series = {Lecture Notes in Computer Science},
	Title = {{HasCASL: Towards Integrated Specification and Development of Functional Programs}},
	Url = {http://www.informatik.uni-bremen.de/~lschrode/hascasl/recursion.ps},
	Volume = {2422},
	Year = {2002},
	Abstract = {The development of programs in modern functional languages such as
	Haskell calls for a wide-spectrum specification formalism that supports
	the type system of such languages, in particular higher order types,
	type constructors, and parametric polymorphism, and that contains
	a functional language as an executable subset in order to facilitate
	rapid prototyping. We lay out the design of HasCASL, a higher order
	extension of the algebraic specification language CASL that is geared
	towards precisely this purpose. Its semantics is tuned to allow program
	development by specification refinement, while at the same time staying
	close to the set-theoretic semantics of first order CASL. The number
	of primitive concepts in the logic has been kept as small as possible;
	we demonstrate how various extensions to the logic, in particular
	general recursion, can be formulated within the language itself.},
	Bdsk-Url-1 = {http://www.informatik.uni-bremen.de/~lschrode/hascasl/recursion.ps},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/3-540-45719-4_8}}

@inproceedings{SchroderMossakowski03a,
	Author = {Lutz Schr{\"o}der and Till Mossakowski},
	Booktitle = {Fundamental Approaches to Software Engineering (FASE 2003)},
	Editor = {Mauro Pezze},
	Keywords = {monads Hoare logic CASL HasCASL},
	Pages = {261--277},
	Psurl = {http://www.informatik.uni-bremen.de/~lschrode/hascasl/monads.ps},
	Publisher = {Springer},
	Series = {Lecture Notes in Computer Science},
	Title = {Monad-independent Hoare logic in {HasCASL}},
	Url = {http://www.informatik.uni-bremen.de/~lschrode/hascasl/monads.ps},
	Volume = {2621},
	Year = {2003},
	Abstract = {Monads have been recognized by Moggi as an elegant device for dealing
	with stateful computation in functional programming languages. It
	is thus natural to develop a Hoare calculus for reasoning about computational
	monads. While this has previously been done only for the state monad,
	we here provide a generic, monad-independent approach, which applies
	also to further computational monads such as exceptions, input/output,
	and non-determinism. All this is formalized within the logic of HasCASL,
	a higher-order language for functional specification and programming.
	Combination of monadic features can be obtained by combining their
	loose specifications. As an application, we prove partial correctness
	of Dijkstra's nondeterministic version of Euclid's algorithm in a
	monad with nondeterministic dynamic references.},
	Bdsk-Url-1 = {http://www.informatik.uni-bremen.de/~lschrode/hascasl/monads.ps}}

@article{SchroderMossakowski08,
	Author = {Lutz Schr{\"o}der and Till Mossakowski},
	Journal = {Theoretical Computer Science},
	Keywords = {Algebraic specification higher order logic functional programming type classes polymorphism CASL monads Hoare logic},
	Number = {12-13},
	Pages = {1217-1260},
	Pdfurl = {http://www.informatik.uni-bremen.de/~lschrode/papers/HasCASL.pdf},
	Title = {{HasCASL}: Integrated Higher-Order Specification and Program Developments},
	Url = {http://www.informatik.uni-bremen.de/~lschrode/papers/HasCASL.pdf},
	Volume = {410},
	Year = {2009},
	Abstract = {We lay out the design of HasCASL, a higher order extension of the
	algebraic specification language CASL that serves both as a wide-spectrum
	language for the rigorous specification and development of software,
	in particular but not exclusively in modern functional programming
	languages, and as an expressive standard language for higher-order
	logic. Distinctive features of HasCASL include partial higher order
	functions, higher order subtyping, shallow polymorphism, and an extensive
	type-class mechanism. Moreover, HasCASL provides dedicated specification
	support for monad-based functional-imperative programming with generic
	side effects, including a monad-based generic Hoare logic.},
	Bdsk-Url-1 = {http://www.informatik.uni-bremen.de/~lschrode/papers/HasCASL.pdf}}

@article{SchroderMossakowski03b,
	Author = {Lutz Schr{\"o}der and Till Mossakowski},
	Journal = {Journal of Logic and Computation},
	Keywords = {HasCASL CASL dynamic logic monad total correctness Hoare calculus},
	Note = {Earlier version appeared in Martin Wirsing, Dirk Pattinson, and Rolf Hennicker (eds.), Recent Trends in Algebraic Development Techniques, 16th International Workshop (WADT 2002), LNCS vol. 2755, Springer, Berlin, 2003, pp. 425-441},
	Number = {4},
	Pages = {571--619},
	Pdfurl = {http://www.informatik.uni-bremen.de/~lschrode/hascasl/monadicpdl.pdf},
	Psurl = {http://www.informatik.uni-bremen.de/~lschrode/hascasl/monadicpdl.ps},
	Title = {Monad-independent dynamic logic in {HasCASL}},
	Url = {http://www.informatik.uni-bremen.de/~lschrode/hascasl/monadicpdl.pdf},
	Volume = {14},
	Year = {2004},
	Abstract = {Monads have been recognized by Moggi as an elegant device for dealing
	with stateful computation in functional programming languages. In
	previous work, we have introduced a Hoare calculus for partial correctness
	of monadic programs. All this has been done in an entirely monad-independent
	way. Here, we extend this to a monad-independent dynamic logic (assuming
	a moderate amount of additional infrastructure for the monad). Dynamic
	logic is more expressive than the Hoare calculus; in particular,
	it allows reasoning about termination and total correctness. As the
	background formalism for these concepts, we use the logic of HasCASL,
	a higher-order language for functional specification and programming.},
	Bdsk-Url-1 = {http://www.informatik.uni-bremen.de/~lschrode/hascasl/monadicpdl.pdf}}

@unpublished{SchroderEtAl03,
	Author = {Lutz Schr{\"o}der and Till Mossakowski and Christian Maeder},
	Pdfurl = {http://www.informatik.uni-bremen.de/agbkb/forschung/formal_methods/CoFI/HasCASL/hascasl_summary.pdf},
	Psurl = {http://www.informatik.uni-bremen.de/agbkb/forschung/formal_methods/CoFI/HasCASL/hascasl_summary.ps},
	Title = {{HasCASL - Integrated functional specification and programming. (Language Summary)}},
	Url = {http://www.informatik.uni-bremen.de/agbkb/forschung/formal_methods/CoFI/HasCASL/hascasl_summary.pdf},
	Year = {2004},
	Abstract = {The development of programs in modern functional languages such as
	Haskell calls for a wide-spectrum specification formalism that supports
	the type system of such languages, in particular higher order types,
	type constructors, and polymorphism, and that contains a functional
	language as an executable subset in order to facilitate rapid prototyping.
	We lay out the design of HasCASL, a higher order extension of CASL
	that is geared towards precisely this purpose. Its semantics is tuned
	to allow program development by specification refinement, while at
	the same time staying close to the set-theoretic semantics of first
	order CASL. The number of primitive concepts in the logic has been
	kept as small as possible; advanced concepts, in particular general
	recursion, can be formulated within the language itself. This document
	provides a detailed definition of the HasCASL syntax and an informal
	description of the semantics, building on the existing CASL Summary.},
	Bdsk-Url-1 = {http://www.informatik.uni-bremen.de/agbkb/forschung/formal_methods/CoFI/HasCASL/hascasl_summary.pdf}}

@book{ObjectZ,
	Address = {Norwell, MA, USA},
	Author = {Graeme Smith},
	Isbn = {0-7923-8684-1},
	Publisher = {Kluwer Academic Publishers},
	Title = {{The Object-Z specification language}},
	Year = {2000}}

@book{ZNotation,
	Author = {John Michael Spivey},
	Edition = {2},
	Isbn = {0-13-983768-X},
	Pages = {158},
	Publisher = {Prentice-Hall},
	Title = {{The Z Notation: a Reference Manual}},
	Url = {http://spivey.oriel.ox.ac.uk/mike/zrm/},
	Year = {1992},
	Bdsk-Url-1 = {http://spivey.oriel.ox.ac.uk/mike/zrm/}}

@electronic{CoqManual,
	Author = {{The Coq Development Team}},
	Organization = {INRIA},
	Title = {{The Coq Proof Assistant -- Reference Manual, v8.1.}},
	Url = {http://coq.inria.fr/doc-eng.html},
	Year = {2006},
	Bdsk-Url-1 = {http://coq.inria.fr/doc-eng.html}}

@book{RaiseSpecification,
	Author = {{The RAISE Language Group}},
	Isbn = {0-13-752833-7},
	Pages = {397},
	Publisher = {Prentice-Hall, Inc.},
	Series = {The BCS Practitioners Series},
	Title = {{The RAISE Specification Language}},
	Year = {1993}}

@book{Thompson1999,
	Author = {Simon Thompson},
	Edition = {2},
	Howpublished = {Paperback},
	Isbn = {0201342758},
	Keywords = {functional-programming, haskell},
	Publisher = {Addison Wesley},
	Title = {{Haskell: The Craft of Functional Programming}},
	Year = {1999}}

@inproceedings{Circus,
	Address = {Dublin, Ireland},
	Author = {Jim Woodcock and Ana Cavalcanti},
	Booktitle = {IWFM'01:~5th Irish Workshop in Formal Methods},
	Editor = {A.~Butterfield and C. Pahl},
	Publisher = {BCS Electronic},
	Series = {Workshops in Computing},
	Title = {A Concurrent Language for Refinement},
	Year = {2001}}
